/*! For license information please see 4060.b87b78e3.js.LICENSE.txt */
"use strict";(self.webpackChunkfunever_front=self.webpackChunkfunever_front||[]).push([[4060],{1965:(t,e,n)=>{n.d(e,{s:()=>p});var r=n(1470),o=n(48898),i=n(40967),s=n(34910),a=n(43653);const{Ph:c,aT:u}=a,l={Err:class extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"")}},_parseInt(t){const{Err:e}=l;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(128&r[0])throw new e("Invalid signature integer: negative");if(0===r[0]&&!(128&r[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:c(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=l,n="string"===typeof t?u(t):t;a.DO(n);let r=n.length;if(r<2||48!=n[0])throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:o,l:i}=l._parseInt(n.subarray(2)),{d:s,l:c}=l._parseInt(i);if(c.length)throw new e("Invalid signature: left bytes after parsing");return{r:o,s:s}},hexFromSig(t){const e=t=>8&Number.parseInt(t[0],16)?"00"+t:t,n=t=>{const e=t.toString(16);return 1&e.length?"0".concat(e):e},r=e(n(t.s)),o=e(n(t.r)),i=r.length/2,s=o.length/2,a=n(i),c=n(s);return"30".concat(n(s+i+4),"02").concat(c).concat(o,"02").concat(a).concat(r)}},f=BigInt(0),h=BigInt(1),d=(BigInt(2),BigInt(3));BigInt(4);function w(t){const e=function(t){const e=(0,i.h)(t);a.Q5(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!==typeof n||"bigint"!==typeof n.beta||"function"!==typeof n.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:n}=e,r=e.toBytes||((t,e,r)=>{const o=e.toAffine();return a.Id(Uint8Array.from([4]),n.toBytes(o.x),n.toBytes(o.y))}),o=e.fromBytes||(t=>{const e=t.subarray(1);return{x:n.fromBytes(e.subarray(0,n.BYTES)),y:n.fromBytes(e.subarray(n.BYTES,2*n.BYTES))}});function c(t){const{a:r,b:o}=e,i=n.sqr(t),s=n.mul(i,t);return n.add(n.add(s,n.mul(t,r)),o)}if(!n.eql(n.sqr(e.Gy),c(e.Gx)))throw new Error("bad generator point: equation left != right");function u(t){return"bigint"===typeof t&&f<t&&t<e.n}function l(t){if(!u(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function w(t){const{allowedPrivateKeyLengths:n,nByteLength:r,wrapPrivateKey:o,n:i}=e;if(n&&"bigint"!==typeof t){if(a.aY(t)&&(t=a.My(t)),"string"!==typeof t||!n.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*r,"0")}let c;try{c="bigint"===typeof t?t:a.Ph((0,a.qj)("private key",t,r))}catch(u){throw new Error("private key must be ".concat(r," bytes, hex or bigint, not ").concat(typeof t))}return o&&(c=s.zi(c,i)),l(c),c}const g=new Map;function y(t){if(!(t instanceof p))throw new Error("ProjectivePoint expected")}class p{constructor(t,e,r){if(this.px=t,this.py=e,this.pz=r,null==t||!n.isValid(t))throw new Error("x required");if(null==e||!n.isValid(e))throw new Error("y required");if(null==r||!n.isValid(r))throw new Error("z required")}static fromAffine(t){const{x:e,y:r}=t||{};if(!t||!n.isValid(e)||!n.isValid(r))throw new Error("invalid affine point");if(t instanceof p)throw new Error("projective point not allowed");const o=t=>n.eql(t,n.ZERO);return o(e)&&o(r)?p.ZERO:new p(e,r,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=n.invertBatch(t.map((t=>t.pz)));return t.map(((t,n)=>t.toAffine(e[n]))).map(p.fromAffine)}static fromHex(t){const e=p.fromAffine(o((0,a.qj)("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return p.BASE.multiply(w(t))}_setWindowSize(t){this._WINDOW_SIZE=t,g.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:t,y:r}=this.toAffine();if(!n.isValid(t)||!n.isValid(r))throw new Error("bad point: x or y not FE");const o=n.sqr(r),i=c(t);if(!n.eql(o,i))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(n.isOdd)return!n.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){y(t);const{px:e,py:r,pz:o}=this,{px:i,py:s,pz:a}=t,c=n.eql(n.mul(e,a),n.mul(i,o)),u=n.eql(n.mul(r,a),n.mul(s,o));return c&&u}negate(){return new p(this.px,n.neg(this.py),this.pz)}double(){const{a:t,b:r}=e,o=n.mul(r,d),{px:i,py:s,pz:a}=this;let c=n.ZERO,u=n.ZERO,l=n.ZERO,f=n.mul(i,i),h=n.mul(s,s),w=n.mul(a,a),g=n.mul(i,s);return g=n.add(g,g),l=n.mul(i,a),l=n.add(l,l),c=n.mul(t,l),u=n.mul(o,w),u=n.add(c,u),c=n.sub(h,u),u=n.add(h,u),u=n.mul(c,u),c=n.mul(g,c),l=n.mul(o,l),w=n.mul(t,w),g=n.sub(f,w),g=n.mul(t,g),g=n.add(g,l),l=n.add(f,f),f=n.add(l,f),f=n.add(f,w),f=n.mul(f,g),u=n.add(u,f),w=n.mul(s,a),w=n.add(w,w),f=n.mul(w,g),c=n.sub(c,f),l=n.mul(w,h),l=n.add(l,l),l=n.add(l,l),new p(c,u,l)}add(t){y(t);const{px:r,py:o,pz:i}=this,{px:s,py:a,pz:c}=t;let u=n.ZERO,l=n.ZERO,f=n.ZERO;const h=e.a,w=n.mul(e.b,d);let g=n.mul(r,s),m=n.mul(o,a),E=n.mul(i,c),b=n.add(r,o),v=n.add(s,a);b=n.mul(b,v),v=n.add(g,m),b=n.sub(b,v),v=n.add(r,i);let B=n.add(s,c);return v=n.mul(v,B),B=n.add(g,E),v=n.sub(v,B),B=n.add(o,i),u=n.add(a,c),B=n.mul(B,u),u=n.add(m,E),B=n.sub(B,u),f=n.mul(h,v),u=n.mul(w,E),f=n.add(u,f),u=n.sub(m,f),f=n.add(m,f),l=n.mul(u,f),m=n.add(g,g),m=n.add(m,g),E=n.mul(h,E),v=n.mul(w,v),m=n.add(m,E),E=n.sub(g,E),E=n.mul(h,E),v=n.add(v,E),g=n.mul(m,v),l=n.add(l,g),g=n.mul(B,v),u=n.mul(b,u),u=n.sub(u,g),g=n.mul(b,m),f=n.mul(B,f),f=n.add(f,g),new p(u,l,f)}subtract(t){return this.add(t.negate())}is0(){return this.equals(p.ZERO)}wNAF(t){return E.wNAFCached(this,g,t,(t=>{const e=n.invertBatch(t.map((t=>t.pz)));return t.map(((t,n)=>t.toAffine(e[n]))).map(p.fromAffine)}))}multiplyUnsafe(t){const r=p.ZERO;if(t===f)return r;if(l(t),t===h)return this;const{endo:o}=e;if(!o)return E.unsafeLadder(this,t);let{k1neg:i,k1:s,k2neg:a,k2:c}=o.splitScalar(t),u=r,d=r,w=this;for(;s>f||c>f;)s&h&&(u=u.add(w)),c&h&&(d=d.add(w)),w=w.double(),s>>=h,c>>=h;return i&&(u=u.negate()),a&&(d=d.negate()),d=new p(n.mul(d.px,o.beta),d.py,d.pz),u.add(d)}multiply(t){l(t);let r,o,i=t;const{endo:s}=e;if(s){const{k1neg:t,k1:e,k2neg:a,k2:c}=s.splitScalar(i);let{p:u,f:l}=this.wNAF(e),{p:f,f:h}=this.wNAF(c);u=E.constTimeNegate(t,u),f=E.constTimeNegate(a,f),f=new p(n.mul(f.px,s.beta),f.py,f.pz),r=u.add(f),o=l.add(h)}else{const{p:t,f:e}=this.wNAF(i);r=t,o=e}return p.normalizeZ([r,o])[0]}multiplyAndAddUnsafe(t,e,n){const r=p.BASE,o=(t,e)=>e!==f&&e!==h&&t.equals(r)?t.multiply(e):t.multiplyUnsafe(e),i=o(this,e).add(o(t,n));return i.is0()?void 0:i}toAffine(t){const{px:e,py:r,pz:o}=this,i=this.is0();null==t&&(t=i?n.ONE:n.inv(o));const s=n.mul(e,t),a=n.mul(r,t),c=n.mul(o,t);if(i)return{x:n.ZERO,y:n.ZERO};if(!n.eql(c,n.ONE))throw new Error("invZ was invalid");return{x:s,y:a}}isTorsionFree(){const{h:t,isTorsionFree:n}=e;if(t===h)return!0;if(n)return n(p,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:n}=e;return t===h?this:n?n(p,this):this.multiplyUnsafe(e.h)}toRawBytes(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this.assertValidity(),r(p,this,t)}toHex(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return a.My(this.toRawBytes(t))}}p.BASE=new p(e.Gx,e.Gy,n.ONE),p.ZERO=new p(n.ZERO,n.ONE,n.ZERO);const m=e.nBitLength,E=(0,i.A)(p,e.endo?Math.ceil(m/2):m);return{CURVE:e,ProjectivePoint:p,normPrivateKeyToScalar:w,weierstrassEquation:c,isWithinCurveOrder:u}}function g(t){const e=function(t){const e=(0,i.h)(t);return a.Q5(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:n,n:r}=e,o=n.BYTES+1,c=2*n.BYTES+1;function u(t){return s.zi(t,r)}function d(t){return s.B8(t,r)}const{ProjectivePoint:g,normPrivateKeyToScalar:y,weierstrassEquation:p,isWithinCurveOrder:m}=w({...e,toBytes(t,e,r){const o=e.toAffine(),i=n.toBytes(o.x),s=a.Id;return r?s(Uint8Array.from([e.hasEvenY()?2:3]),i):s(Uint8Array.from([4]),i,n.toBytes(o.y))},fromBytes(t){const e=t.length,r=t[0],i=t.subarray(1);if(e!==o||2!==r&&3!==r){if(e===c&&4===r){return{x:n.fromBytes(i.subarray(0,n.BYTES)),y:n.fromBytes(i.subarray(n.BYTES,2*n.BYTES))}}throw new Error("Point of length ".concat(e," was invalid. Expected ").concat(o," compressed bytes or ").concat(c," uncompressed bytes"))}{const t=a.Ph(i);if(!(f<(s=t)&&s<n.ORDER))throw new Error("Point is not on curve");const e=p(t);let o;try{o=n.sqrt(e)}catch(u){const t=u instanceof Error?": "+u.message:"";throw new Error("Point is not on curve"+t)}return 1===(1&r)!==((o&h)===h)&&(o=n.neg(o)),{x:t,y:o}}var s}}),E=t=>a.My(a.lq(t,e.nByteLength));function b(t){return t>r>>h}const v=(t,e,n)=>a.Ph(t.slice(e,n));class B{constructor(t,e,n){this.r=t,this.s=e,this.recovery=n,this.assertValidity()}static fromCompact(t){const n=e.nByteLength;return t=(0,a.qj)("compactSignature",t,2*n),new B(v(t,0,n),v(t,n,2*n))}static fromDER(t){const{r:e,s:n}=l.toSig((0,a.qj)("DER",t));return new B(e,n)}assertValidity(){if(!m(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!m(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new B(this.r,this.s,t)}recoverPublicKey(t){const{r:r,s:o,recovery:i}=this,s=q((0,a.qj)("msgHash",t));if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");const c=2===i||3===i?r+e.n:r;if(c>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const l=0===(1&i)?"02":"03",f=g.fromHex(l+E(c)),h=d(c),w=u(-s*h),y=u(o*h),p=g.BASE.multiplyAndAddUnsafe(f,w,y);if(!p)throw new Error("point at infinify");return p.assertValidity(),p}hasHighS(){return b(this.s)}normalizeS(){return this.hasHighS()?new B(this.r,u(-this.s),this.recovery):this}toDERRawBytes(){return a.aT(this.toDERHex())}toDERHex(){return l.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return a.aT(this.toCompactHex())}toCompactHex(){return E(this.r)+E(this.s)}}const x={isValidPrivateKey(t){try{return y(t),!0}catch(e){return!1}},normPrivateKeyToScalar:y,randomPrivateKey:()=>{const t=s.Tp(e.n);return s.qy(e.randomBytes(t),e.n)},precompute(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:8,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:g.BASE;return e._setWindowSize(t),e.multiply(BigInt(3)),e}};function S(t){const e=a.aY(t),n="string"===typeof t,r=(e||n)&&t.length;return e?r===o||r===c:n?r===2*o||r===2*c:t instanceof g}const A=e.bits2int||function(t){const n=a.Ph(t),r=8*t.length-e.nBitLength;return r>0?n>>BigInt(r):n},q=e.bits2int_modN||function(t){return u(A(t))},O=a.OG(e.nBitLength);function I(t){if("bigint"!==typeof t)throw new Error("bigint expected");if(!(f<=t&&t<O))throw new Error("bigint expected < 2^".concat(e.nBitLength));return a.lq(t,e.nByteLength)}function R(t,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:z;if(["recovered","canonical"].some((t=>t in o)))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:s}=e;let{lowS:c,prehash:l,extraEntropy:w}=o;null==c&&(c=!0),t=(0,a.qj)("msgHash",t),l&&(t=(0,a.qj)("prehashed msgHash",i(t)));const p=q(t),E=y(r),v=[I(E),I(p)];if(null!=w&&!1!==w){const t=!0===w?s(n.BYTES):w;v.push((0,a.qj)("extraEntropy",t))}const x=a.Id(...v),S=p;return{seed:x,k2sig:function(t){const e=A(t);if(!m(e))return;const n=d(e),r=g.BASE.multiply(e).toAffine(),o=u(r.x);if(o===f)return;const i=u(n*u(S+o*E));if(i===f)return;let s=(r.x===o?0:2)|Number(r.y&h),a=i;return c&&b(i)&&(a=function(t){return b(t)?u(-t):t}(i),s^=1),new B(o,a,s)}}}const z={lowS:e.lowS,prehash:!1},N={lowS:e.lowS,prehash:!1};return g.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return g.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(S(t))throw new Error("first arg must be private key");if(!S(e))throw new Error("second arg must be public key");return g.fromHex(e).multiply(y(t)).toRawBytes(n)},sign:function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:z;const{seed:o,k2sig:i}=R(t,n,r),s=e;return a.fg(s.hash.outputLen,s.nByteLength,s.hmac)(o,i)},verify:function(t,n,r){var o;let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N;const s=t;if(n=(0,a.qj)("msgHash",n),r=(0,a.qj)("publicKey",r),"strict"in i)throw new Error("options.strict was renamed to lowS");const{lowS:c,prehash:f}=i;let h,w;try{if("string"===typeof s||a.aY(s))try{h=B.fromDER(s)}catch(S){if(!(S instanceof l.Err))throw S;h=B.fromCompact(s)}else{if("object"!==typeof s||"bigint"!==typeof s.r||"bigint"!==typeof s.s)throw new Error("PARSE");{const{r:t,s:e}=s;h=new B(t,e)}}w=g.fromHex(r)}catch(A){if("PARSE"===A.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(c&&h.hasHighS())return!1;f&&(n=e.hash(n));const{r:y,s:p}=h,m=q(n),E=d(p),b=u(m*E),v=u(y*E),x=null===(o=g.BASE.multiplyAndAddUnsafe(w,b,v))||void 0===o?void 0:o.toAffine();return!!x&&u(x.x)===y},ProjectivePoint:g,Signature:B,utils:x}}function y(t){return{hash:t,hmac:function(e){for(var n=arguments.length,i=new Array(n>1?n-1:0),s=1;s<n;s++)i[s-1]=arguments[s];return(0,r.w)(t,e,(0,o.Id)(...i))},randomBytes:o.po}}function p(t,e){const n=e=>g({...t,...y(e)});return Object.freeze({...n(e),create:n})}},40967:(t,e,n)=>{n.d(e,{A:()=>a,h:()=>c});var r=n(34910),o=n(43653);const i=BigInt(0),s=BigInt(1);function a(t,e){const n=(t,e)=>{const n=e.negate();return t?n:e},r=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:n,unsafeLadder(e,n){let r=t.ZERO,o=e;for(;n>i;)n&s&&(r=r.add(o)),o=o.double(),n>>=s;return r},precomputeWindow(t,e){const{windows:n,windowSize:o}=r(e),i=[];let s=t,a=s;for(let r=0;r<n;r++){a=s,i.push(a);for(let t=1;t<o;t++)a=a.add(s),i.push(a);s=a.double()}return i},wNAF(e,o,i){const{windows:a,windowSize:c}=r(e);let u=t.ZERO,l=t.BASE;const f=BigInt(2**e-1),h=2**e,d=BigInt(e);for(let t=0;t<a;t++){const e=t*c;let r=Number(i&f);i>>=d,r>c&&(r-=h,i+=s);const a=e,w=e+Math.abs(r)-1,g=t%2!==0,y=r<0;0===r?l=l.add(n(g,o[a])):u=u.add(n(y,o[w]))}return{p:u,f:l}},wNAFCached(t,e,n,r){const o=t._WINDOW_SIZE||1;let i=e.get(t);return i||(i=this.precomputeWindow(t,o),1!==o&&e.set(t,r(i))),this.wNAF(o,i,n)}}}function c(t){return(0,r.jr)(t.Fp),(0,o.Q5)(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,r.LH)(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}},21352:(t,e,n)=>{n.d(e,{n:()=>f});var r=n(40967),o=n(34910),i=n(43653);const s=BigInt(0),a=BigInt(1),c=BigInt(2),u=BigInt(8),l={zip215:!0};function f(t){const e=function(t){const e=(0,r.h)(t);return i.Q5(t,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}(t),{Fp:n,n:f,prehash:h,hash:d,randomBytes:w,nByteLength:g,h:y}=e,p=c<<BigInt(8*g)-a,m=n.create,E=e.uvRatio||((t,e)=>{try{return{isValid:!0,value:n.sqrt(t*n.inv(e))}}catch(r){return{isValid:!1,value:s}}}),b=e.adjustScalarBytes||(t=>t),v=e.domain||((t,e,n)=>{if(e.length||n)throw new Error("Contexts/pre-hash are not supported");return t}),B=t=>"bigint"===typeof t&&s<t,x=(t,e)=>B(t)&&B(e)&&t<e,S=t=>t===s||x(t,p);function A(t,e){if(x(t,e))return t;throw new Error("Expected valid scalar < ".concat(e,", got ").concat(typeof t," ").concat(t))}function q(t){return t===s?t:A(t,f)}const O=new Map;function I(t){if(!(t instanceof R))throw new Error("ExtendedPoint expected")}class R{constructor(t,e,n,r){if(this.ex=t,this.ey=e,this.ez=n,this.et=r,!S(t))throw new Error("x required");if(!S(e))throw new Error("y required");if(!S(n))throw new Error("z required");if(!S(r))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(t){if(t instanceof R)throw new Error("extended point not allowed");const{x:e,y:n}=t||{};if(!S(e)||!S(n))throw new Error("invalid affine point");return new R(e,n,a,m(e*n))}static normalizeZ(t){const e=n.invertBatch(t.map((t=>t.ez)));return t.map(((t,n)=>t.toAffine(e[n]))).map(R.fromAffine)}_setWindowSize(t){this._WINDOW_SIZE=t,O.delete(this)}assertValidity(){const{a:t,d:n}=e;if(this.is0())throw new Error("bad point: ZERO");const{ex:r,ey:o,ez:i,et:s}=this,a=m(r*r),c=m(o*o),u=m(i*i),l=m(u*u),f=m(a*t);if(m(u*m(f+c))!==m(l+m(n*m(a*c))))throw new Error("bad point: equation left != right (1)");if(m(r*o)!==m(i*s))throw new Error("bad point: equation left != right (2)")}equals(t){I(t);const{ex:e,ey:n,ez:r}=this,{ex:o,ey:i,ez:s}=t,a=m(e*s),c=m(o*r),u=m(n*s),l=m(i*r);return a===c&&u===l}is0(){return this.equals(R.ZERO)}negate(){return new R(m(-this.ex),this.ey,this.ez,m(-this.et))}double(){const{a:t}=e,{ex:n,ey:r,ez:o}=this,i=m(n*n),s=m(r*r),a=m(c*m(o*o)),u=m(t*i),l=n+r,f=m(m(l*l)-i-s),h=u+s,d=h-a,w=u-s,g=m(f*d),y=m(h*w),p=m(f*w),E=m(d*h);return new R(g,y,E,p)}add(t){I(t);const{a:n,d:r}=e,{ex:o,ey:i,ez:a,et:u}=this,{ex:l,ey:f,ez:h,et:d}=t;if(n===BigInt(-1)){const t=m((i-o)*(f+l)),e=m((i+o)*(f-l)),n=m(e-t);if(n===s)return this.double();const r=m(a*c*d),w=m(u*c*h),g=w+r,y=e+t,p=w-r,E=m(g*n),b=m(y*p),v=m(g*p),B=m(n*y);return new R(E,b,B,v)}const w=m(o*l),g=m(i*f),y=m(u*r*d),p=m(a*h),E=m((o+i)*(l+f)-w-g),b=p-y,v=p+y,B=m(g-n*w),x=m(E*b),S=m(v*B),A=m(E*B),q=m(b*v);return new R(x,S,q,A)}subtract(t){return this.add(t.negate())}wNAF(t){return P.wNAFCached(this,O,t,R.normalizeZ)}multiply(t){const{p:e,f:n}=this.wNAF(A(t,f));return R.normalizeZ([e,n])[0]}multiplyUnsafe(t){let e=q(t);return e===s?N:this.equals(N)||e===a?this:this.equals(z)?this.wNAF(e).p:P.unsafeLadder(this,e)}isSmallOrder(){return this.multiplyUnsafe(y).is0()}isTorsionFree(){return P.unsafeLadder(this,f).is0()}toAffine(t){const{ex:e,ey:r,ez:o}=this,i=this.is0();null==t&&(t=i?u:n.inv(o));const c=m(e*t),l=m(r*t),f=m(o*t);if(i)return{x:s,y:a};if(f!==a)throw new Error("invZ was invalid");return{x:c,y:l}}clearCofactor(){const{h:t}=e;return t===a?this:this.multiplyUnsafe(t)}static fromHex(t){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const{d:o,a:c}=e,u=n.BYTES,l=(t=(0,i.qj)("pointHex",t,u)).slice(),f=t[u-1];l[u-1]=-129&f;const h=i.lX(l);h===s||A(h,r?p:n.ORDER);const d=m(h*h),w=m(d-a),g=m(o*d-c);let{isValid:y,value:b}=E(w,g);if(!y)throw new Error("Point.fromHex: invalid y coordinate");const v=(b&a)===a,B=0!==(128&f);if(!r&&b===s&&B)throw new Error("Point.fromHex: x=0 and x_0=1");return B!==v&&(b=m(-b)),R.fromAffine({x:b,y:h})}static fromPrivateKey(t){return Z(t).point}toRawBytes(){const{x:t,y:e}=this.toAffine(),r=i.z(e,n.BYTES);return r[r.length-1]|=t&a?128:0,r}toHex(){return i.My(this.toRawBytes())}}R.BASE=new R(e.Gx,e.Gy,a,m(e.Gx*e.Gy)),R.ZERO=new R(s,a,a,s);const{BASE:z,ZERO:N}=R,P=(0,r.A)(R,8*g);function j(t){return(0,o.zi)(t,f)}function T(t){return j(i.lX(t))}function Z(t){const e=g;t=(0,i.qj)("private key",t,e);const n=(0,i.qj)("hashed private key",d(t),2*e),r=b(n.slice(0,e)),o=n.slice(e,2*e),s=T(r),a=z.multiply(s),c=a.toRawBytes();return{head:r,prefix:o,scalar:s,point:a,pointBytes:c}}function F(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Uint8Array;for(var e=arguments.length,n=new Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];const o=i.Id(...n);return T(d(v(o,(0,i.qj)("context",t),!!h)))}const _=l;z._setWindowSize(8);const U={getExtendedPublicKey:Z,randomPrivateKey:()=>w(n.BYTES),precompute(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:8,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R.BASE;return e._setWindowSize(t),e.multiply(BigInt(3)),e}};return{CURVE:e,getPublicKey:function(t){return Z(t).pointBytes},sign:function(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t=(0,i.qj)("message",t),h&&(t=h(t));const{prefix:o,scalar:s,pointBytes:a}=Z(e),c=F(r.context,o,t),u=z.multiply(c).toRawBytes(),l=j(c+F(r.context,u,a,t)*s);q(l);const f=i.Id(u,i.z(l,n.BYTES));return(0,i.qj)("result",f,2*g)},verify:function(t,e,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:_;const{context:s,zip215:a}=o,c=n.BYTES;t=(0,i.qj)("signature",t,2*c),e=(0,i.qj)("message",e),h&&(e=h(e));const u=i.lX(t.slice(c,2*c));let l,f,d;try{l=R.fromHex(r,a),f=R.fromHex(t.slice(0,c),a),d=z.multiplyUnsafe(u)}catch(g){return!1}if(!a&&l.isSmallOrder())return!1;const w=F(s,f.toRawBytes(),l.toRawBytes(),e);return f.add(l.multiplyUnsafe(w)).subtract(d).clearCofactor().equals(R.ZERO)},ExtendedPoint:R,utils:U}}},34910:(t,e,n)=>{n.d(e,{B8:()=>w,D0:()=>b,LH:()=>E,Tp:()=>B,dQ:()=>y,jr:()=>m,qy:()=>x,zH:()=>d,zi:()=>f});var r=n(43653);const o=BigInt(0),i=BigInt(1),s=BigInt(2),a=BigInt(3),c=BigInt(4),u=BigInt(5),l=BigInt(8);BigInt(9),BigInt(16);function f(t,e){const n=t%e;return n>=o?n:e+n}function h(t,e,n){if(n<=o||e<o)throw new Error("Expected power/modulo > 0");if(n===i)return o;let r=i;for(;e>o;)e&i&&(r=r*t%n),t=t*t%n,e>>=i;return r}function d(t,e,n){let r=t;for(;e-- >o;)r*=r,r%=n;return r}function w(t,e){if(t===o||e<=o)throw new Error("invert: expected positive integers, got n=".concat(t," mod=").concat(e));let n=f(t,e),r=e,s=o,a=i,c=i,u=o;for(;n!==o;){const t=r/n,e=r%n,o=s-c*t,i=a-u*t;r=n,n=e,s=c,a=u,c=o,u=i}if(r!==i)throw new Error("invert: does not exist");return f(s,e)}function g(t){if(t%c===a){const e=(t+i)/c;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}if(t%l===u){const e=(t-u)/l;return function(t,n){const r=t.mul(n,s),o=t.pow(r,e),i=t.mul(n,o),a=t.mul(t.mul(i,s),o),c=t.mul(i,t.sub(a,t.ONE));if(!t.eql(t.sqr(c),n))throw new Error("Cannot find square root");return c}}return function(t){const e=(t-i)/s;let n,r,a;for(n=t-i,r=0;n%s===o;n/=s,r++);for(a=s;a<t&&h(a,e,t)!==t-i;a++);if(1===r){const e=(t+i)/c;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}const u=(n+i)/s;return function(t,o){if(t.pow(o,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let s=r,c=t.pow(t.mul(t.ONE,a),n),l=t.pow(o,u),f=t.pow(o,n);for(;!t.eql(f,t.ONE);){if(t.eql(f,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(f);e<s&&!t.eql(r,t.ONE);e++)r=t.sqr(r);const n=t.pow(c,i<<BigInt(s-e-1));c=t.sqr(n),l=t.mul(l,n),f=t.mul(f,c),s=e}return l}}(t)}const y=(t,e)=>(f(t,e)&i)===i,p=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function m(t){const e=p.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return(0,r.Q5)(t,e)}function E(t,e){const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function b(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(t<=o)throw new Error("Expected Field ORDER > 0, got ".concat(t));const{nBitLength:a,nByteLength:c}=E(t,e);if(c>2048)throw new Error("Field lengths over 2048 bytes are not supported");const u=g(t),l=Object.freeze({ORDER:t,BITS:a,BYTES:c,MASK:(0,r.OG)(a),ZERO:o,ONE:i,create:e=>f(e,t),isValid:e=>{if("bigint"!==typeof e)throw new Error("Invalid field element: expected bigint, got ".concat(typeof e));return o<=e&&e<t},is0:t=>t===o,isOdd:t=>(t&i)===i,neg:e=>f(-e,t),eql:(t,e)=>t===e,sqr:e=>f(e*e,t),add:(e,n)=>f(e+n,t),sub:(e,n)=>f(e-n,t),mul:(e,n)=>f(e*n,t),pow:(t,e)=>function(t,e,n){if(n<o)throw new Error("Expected power > 0");if(n===o)return t.ONE;if(n===i)return e;let r=t.ONE,s=e;for(;n>o;)n&i&&(r=t.mul(r,s)),s=t.sqr(s),n>>=i;return r}(l,t,e),div:(e,n)=>f(e*w(n,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>w(e,t),sqrt:s.sqrt||(t=>u(l,t)),invertBatch:t=>function(t,e){const n=new Array(e.length),r=e.reduce(((e,r,o)=>t.is0(r)?e:(n[o]=e,t.mul(e,r))),t.ONE),o=t.inv(r);return e.reduceRight(((e,r,o)=>t.is0(r)?e:(n[o]=t.mul(e,n[o]),t.mul(e,r))),o),n}(l,t),cmov:(t,e,n)=>n?e:t,toBytes:t=>n?(0,r.z)(t,c):(0,r.lq)(t,c),fromBytes:t=>{if(t.length!==c)throw new Error("Fp.fromBytes: expected ".concat(c,", got ").concat(t.length));return n?(0,r.lX)(t):(0,r.Ph)(t)}});return Object.freeze(l)}function v(t){if("bigint"!==typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function B(t){const e=v(t);return e+Math.ceil(e/2)}function x(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=t.length,s=v(e),a=B(e);if(o<16||o<a||o>1024)throw new Error("expected ".concat(a,"-1024 bytes of input, got ").concat(o));const c=f(n?(0,r.Ph)(t):(0,r.lX)(t),e-i)+i;return n?(0,r.z)(c,s):(0,r.lq)(c,s)}},43653:(t,e,n)=>{n.d(e,{DO:()=>s,Id:()=>m,My:()=>c,OG:()=>E,Ph:()=>d,Q5:()=>S,aT:()=>h,aY:()=>i,fg:()=>B,lX:()=>w,lq:()=>g,qj:()=>p,z:()=>y});const r=BigInt(1),o=BigInt(2);function i(t){return t instanceof Uint8Array||null!=t&&"object"===typeof t&&"Uint8Array"===t.constructor.name}function s(t){if(!i(t))throw new Error("Uint8Array expected")}const a=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function c(t){s(t);let e="";for(let n=0;n<t.length;n++)e+=a[t[n]];return e}function u(t){if("string"!==typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":"0x".concat(t))}const l={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function f(t){return t>=l._0&&t<=l._9?t-l._0:t>=l._A&&t<=l._F?t-(l._A-10):t>=l._a&&t<=l._f?t-(l._a-10):void 0}function h(t){if("string"!==typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let o=0,i=0;o<n;o++,i+=2){const e=f(t.charCodeAt(i)),n=f(t.charCodeAt(i+1));if(void 0===e||void 0===n){const e=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+i)}r[o]=16*e+n}return r}function d(t){return u(c(t))}function w(t){return s(t),u(c(Uint8Array.from(t).reverse()))}function g(t,e){return h(t.toString(16).padStart(2*e,"0"))}function y(t,e){return g(t,e).reverse()}function p(t,e,n){let r;if("string"===typeof e)try{r=h(e)}catch(s){throw new Error("".concat(t,' must be valid hex string, got "').concat(e,'". Cause: ').concat(s))}else{if(!i(e))throw new Error("".concat(t," must be hex string or Uint8Array"));r=Uint8Array.from(e)}const o=r.length;if("number"===typeof n&&o!==n)throw new Error("".concat(t," expected ").concat(n," bytes, got ").concat(o));return r}function m(){let t=0;for(let n=0;n<arguments.length;n++){const e=n<0||arguments.length<=n?void 0:arguments[n];s(e),t+=e.length}const e=new Uint8Array(t);for(let n=0,r=0;n<arguments.length;n++){const t=n<0||arguments.length<=n?void 0:arguments[n];e.set(t,r),r+=t.length}return e}const E=t=>(o<<BigInt(t-1))-r,b=t=>new Uint8Array(t),v=t=>Uint8Array.from(t);function B(t,e,n){if("number"!==typeof t||t<2)throw new Error("hashLen must be a number");if("number"!==typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!==typeof n)throw new Error("hmacFn must be a function");let r=b(t),o=b(t),i=0;const s=()=>{r.fill(1),o.fill(0),i=0},a=function(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];return n(o,r,...e)},c=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:b();o=a(v([0]),t),r=a(),0!==t.length&&(o=a(v([1]),t),r=a())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const n=[];for(;t<e;){r=a();const e=r.slice();n.push(e),t+=r.length}return m(...n)};return(t,e)=>{let n;for(s(),c(t);!(n=e(u()));)c();return s(),n}}const x={bigint:t=>"bigint"===typeof t,function:t=>"function"===typeof t,boolean:t=>"boolean"===typeof t,string:t=>"string"===typeof t,stringOrUint8Array:t=>"string"===typeof t||i(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"===typeof t&&Number.isSafeInteger(t.outputLen)};function S(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=(e,n,r)=>{const o=x[n];if("function"!==typeof o)throw new Error('Invalid validator "'.concat(n,'", expected function'));const i=t[e];if((!r||void 0!==i)&&!o(i,t))throw new Error("Invalid param ".concat(String(e),"=").concat(i," (").concat(typeof i,"), expected ").concat(n))};for(const[o,i]of Object.entries(e))r(o,i,!1);for(const[o,i]of Object.entries(n))r(o,i,!0);return t}}}]);